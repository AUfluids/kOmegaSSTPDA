/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Copyright (C) 2024 M. J. Rinc√≥n
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Class
    Foam::expressionParser

Description
    Runtime expression parser for symbolic regression expressions.
    Uses ExprTK library for fast expression evaluation.

    Expressions can be read from JSON files generated by PySR,
    allowing modification without recompilation.

SourceFiles
    expressionParser.C

\*---------------------------------------------------------------------------*/

#ifndef expressionParser_H
#define expressionParser_H

#include "fvMesh.H"
#include "volFields.H"
#include "dictionary.H"
#include <string>
#include <map>
#include <memory>

// Include ExprTK if available
#ifdef EXPRTK_AVAILABLE
    #include "exprtk.hpp"
    #define USE_EXPRTK
#endif

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

/*---------------------------------------------------------------------------*\
                      Class expressionParser Declaration
\*---------------------------------------------------------------------------*/

class expressionParser
{
    // Private Member Data

        //- Expression string
        std::string expressionStr_;

#ifdef USE_EXPRTK
        //- ExprTK expression object
        std::unique_ptr<exprtk::expression<double>> expression_;

        //- ExprTK parser object
        std::unique_ptr<exprtk::parser<double>> parser_;

        //- ExprTK symbol table
        std::unique_ptr<exprtk::symbol_table<double>> symbolTable_;
#endif

        //- Map of variable names to their field pointers (for field evaluation)
        std::map<std::string, const volScalarField*> fieldVariables_;

        //- Map of variable names to scalar pointers (for scalar evaluation)
        std::map<std::string, double*> scalarVariables_;

        //- Map of constant names to their values
        std::map<std::string, double> constants_;

        //- Flag indicating if expression is compiled
        bool compiled_;

    // Private Member Functions

        //- Compile the expression
        bool compileExpression();

public:

    // Constructors

        //- Construct from expression string
        expressionParser(const std::string& expr = "");

        //- Construct from dictionary
        expressionParser(const dictionary& dict);

        //- Copy constructor (deleted)
        expressionParser(const expressionParser&) = delete;

    // Destructor

        ~expressionParser();

    // Member Functions

        //- Set expression string
        void setExpression(const std::string& expr);

        //- Get expression string
        const std::string& expression() const { return expressionStr_; }

        //- Register field variable (for cell-by-cell evaluation)
        void registerFieldVariable(const std::string& name, const volScalarField& field);

        //- Register scalar variable (for single value evaluation)
        void registerScalarVariable(const std::string& name, double* value);

        //- Register constant value
        void registerConstant(const std::string& name, const dimensionedScalar& value);
        
        //- Register constant value (double)
        void registerConstant(const std::string& name, double value);

        //- Evaluate expression for a single value (using current variable values)
        double evaluate() const;

        //- Evaluate expression for entire field
        void evaluateField(volScalarField& result) const;

        //- Check if expression is valid
        bool isValid() const { return compiled_; }

        //- Read from dictionary
        void read(const dictionary& dict);

        //- Write to dictionary
        void write(Ostream& os) const;
};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#endif

// ************************************************************************* //
